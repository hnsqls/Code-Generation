## 项目介绍

代码生成器项目，生成代码模板。



## 项目拆解

* 基于命令行生成代码





## 第一阶段本地代码生成器

主要目的：基于命令行方式开发代码生成器，也就是开发一个脚手架。

### 核心思路

完整代码 = **静态代码** + **动态模板** + **动态参数**。

代码生成是根据一个项目代码的模板以及传入一些参数来选择是否需要，来生成完整的代码。

对于**静态代码**也就是通用的不需要改变的代码，怎么生成？

直接**复制代码文件**就好，或则pull远程仓库中的模板代码。

### 业务流程

1. 准备模板代码，用于后续生成
2. 基于模板代码，设置参数，编写动态的模板
3. 制作可以可交互的命令行工具，支持用户输入参数，得到代码生成器jar包
4. 使用者可以下载制作好的jar包，执行程序并输入参数，从而生成完整代码。

业务流程图如下：

![image-20250122105547679](images/开发手册.assets/image-20250122105547679.png)

### 实现思路

1. 根据原始代码，可以生成一样的代码，可以两种方式，一种是copy，一种是pull。
2. 根据原始代码，预设部分动态的参数，编写模板文件，能够出入配置对象进行生成
3. 制作命令行工具，接受用户输入参数，动态生成代码
4. 封装代码生成器jar包，简化使用命令



问题拆解

1. 如何根据一套项目文件，完整的生成一套项目？（copy 或则pull）
2. 如何编写动态模板文件以及根据参数生成代码。
3. 如何制作命令行？接受用户输入
4. 怎么将命令行工具打给别人使用。



### 项目初始化

jdk 1.8

准备代码模板

```java
import java.util.Scanner;

/**
 * ACM 输入模板（多数之和）
 */
public class MainTemplate {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()) {
            // 读取输入元素个数
            int n = scanner.nextInt();

            // 读取数组
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }

            // 处理问题逻辑，根据需要进行输出
            // 示例：计算数组元素的和
            int sum = 0;
            for (int num : arr) {
                sum += num;
            }

            System.out.println("Sum: " + sum);
        }

        scanner.close();
    }
}

```

创建maven项目

依赖

```xml
<dependencies>
    <!-- https://doc.hutool.cn/ -->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.8.16</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-collections4</artifactId>
        <version>4.4</version>
    </dependency>
    <!-- https://projectlombok.org/ -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>

```

#### 实现流程

明确目的：制作一个代码生成器的脚手架。

任务拆解：在本地做一个代码生成器 + 基于命令行的脚手架。

模板代码分析

![image-20250122120045109](images/开发手册.assets/image-20250122120045109.png)

readme.md代码不需要更改，属于”静态文件“，直接复制。 

java代码我们要根据我们预设的参数生成完整代码。

比如现在的代码是一直循环输入

```java
Scanner scanner = new Scanner(System.in);

while (scanner.hasNext()) {
    // 读取输入元素个数
    int n = scanner.nextInt();
    ...
    System.out.println("Sum: " + sum);
}

```

但是如果用户不需要一直循环输入，只保留其他代码如下

```java
Scanner scanner = new Scanner(System.in);

// 读取输入元素个数
int n = scanner.nextInt();
...
System.out.println("Sum: " + sum);

```

也就是说，该java代码是"动态的"，根据用户输入的参数来生成不同的代码。

通过上个步骤可以分为生成**静态文件** + **动态文件**。

在思考如何制作基于命令行的脚手架，在做脚手架之前可以通过运行Main方法生成代码。然后改变参数的输入方式，在命令行获取参数复用逻辑，在改变执行方式调用jar包

实现步骤

1. 生成静态文件，通过main方法执行
2. 生成动态文件，通过main方法执行
3. 同时生成静态文件+动态文件，通过main方法执行，得到完整代码
4. 开发命令行工具，接受参数生成要求代码

#### 生成静态代码

使用hutool工具copy。

```java
public class StaticGenerator {
    public static void copyFilesByhutool(String inputPath,String outputPath) {
        FileUtil.copy(inputPath,outputPath,false);
    }
}
```

hutool源代码如下

```java
	/**
	 * 复制文件或目录<br>
	 * 如果目标文件为目录，则将源文件以相同文件名拷贝到目标目录
	 *
	 * @param srcPath    源文件或目录
	 * @param destPath   目标文件或目录，目标不存在会自动创建（目录、文件都创建）
	 * @param isOverride 是否覆盖目标文件
	 * @return 目标目录或文件
	 * @throws IORuntimeException IO异常
	 */
	public static File copy(String srcPath, String destPath, boolean isOverride) throws IORuntimeException {
		return copy(file(srcPath), file(destPath), isOverride);
	}
```

编写main方法

```java
public class Main {
    public static void main(String[] args) {
        // 获取整个项目的根路径
        String projectPath = System.getProperty("user.dir");
//        System.out.println("projectPath = " + projectPath);
        // 获取项目根路径的父路径
        File parentFile = new File(projectPath).getParentFile();
//        System.out.println("parentFile = " + parentFile);
        // 输入路径：ACM 示例代码模板目录
        String inputPath = new File(parentFile, "ls-generator-demo/acm-template").getAbsolutePath();
        // 输出路径：直接输出到项目的根目录
        String outputPath = projectPath;
        StaticGenerator.copyFilesByhutool(inputPath, outputPath);
    }
}
```

测试

确实生成了

![image-20250122124628408](images/开发手册.assets/image-20250122124628408.png)

这样好处就是使用简单，但是没办法自定义那个文件要生成那个文件不要复制。

对于该demo而言，只需要copy `readme.md`文档以及各个目录。

可以自己递归实现文件的遍历。

```java
/**
     * 递归拷贝文件（递归实现，会将输入目录完整拷贝到输出目录下）
     * @param inputPath
     * @param outputPath
     */
    public static void copyFilesByRecursive(String inputPath, String outputPath) {
        File inputFile = new File(inputPath);
        File outputFile = new File(outputPath);
        try {
            copyFileByRecursive(inputFile, outputFile);
        } catch (Exception e) {
            System.err.println("文件复制失败");
            e.printStackTrace();
        }
    }

    /**
     * 文件 A => 目录 B，则文件 A 放在目录 B 下
     * 文件 A => 文件 B，则文件 A 覆盖文件 B
     * 目录 A => 目录 B，则目录 A 放在目录 B 下
     *
     * 核心思路：先创建目录，然后遍历目录内的文件，依次复制
     * @param inputFile
     * @param outputFile
     * @throws IOException
     */
    private static void copyFileByRecursive(File inputFile, File outputFile) throws IOException {
        // 区分是文件还是目录
        if (inputFile.isDirectory()) {
            System.out.println(inputFile.getName());
            File destOutputFile = new File(outputFile, inputFile.getName());
            // 如果是目录，首先创建目标目录
            if (!destOutputFile.exists()) {
                destOutputFile.mkdirs();
            }
            // 获取目录下的所有文件和子目录
            File[] files = inputFile.listFiles();
            // 无子文件，直接结束
            if (ArrayUtil.isEmpty(files)) {
                return;
            }
            for (File file : files) {
                // 递归拷贝下一层文件
                copyFileByRecursive(file, destOutputFile);
            }
        } else {
            // 是文件，直接复制到目标目录下
            Path destPath = outputFile.toPath().resolve(inputFile.getName());
            Files.copy(inputFile.toPath(), destPath, StandardCopyOption.REPLACE_EXISTING);
        }
    }





    /**
     * 递归遍历文件
     * @param directory
     */
    public static void traverseFiles(File directory) {
        // 如果是目录
        if (directory.isDirectory()) {
            // 获取当前目录下的所有文件和子目录
            File[] files = directory.listFiles();

            if (files != null) {
                // 遍历每一个文件和子目录
                for (File file : files) {
                    // 如果是文件，复制文件
                    if (file.isFile()) {

                    }
                    // 如果是目录，递归调用
                    else if (file.isDirectory()) {
                        System.out.println("Directory: " + file.getAbsolutePath());
                        traverseFiles(file); // 递归遍历子目录
                    }
                }
            }
        }
```

测试

```java 
/**
     * 递归遍历文件测试
     * @param directory
     */
    public static void traverseFiles(File directory) {
        // 如果是目录
        if (directory.isDirectory()) {
            // 获取当前目录下的所有文件和子目录
            File[] files = directory.listFiles();

            if (files != null) {
                // 遍历每一个文件和子目录
                for (File file : files) {
                    // 如果是文件，复制文件
                    if (file.isFile()) {

                    }
                    // 如果是目录，递归调用
                    else if (file.isDirectory()) {
                        System.out.println("Directory: " + file.getAbsolutePath());
                        traverseFiles(file); // 递归遍历子目录
                    }
                }
            }
        }
    }
```

测试正常

![image-20250122151550577](images/开发手册.assets/image-20250122151550577.png)

